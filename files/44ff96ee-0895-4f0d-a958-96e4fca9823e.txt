先来引入numpy下的所有方法:

>>> from numpy import *

我们创建一个a，如图下图，使用tile来创建b，注意看b的数据结构:

>>> a=[0,1,2]
>>> b=tile(a,2)
>>> b
array([0, 1, 2, 0, 1, 2])

假如我们输入一个元组(1,2)，我们会得到一样的结果，与上面相同的b

>>> b=tile(a,(1,2))
>>> b
array([[0, 1, 2, 0, 1, 2]])

当然，我们想要a变为一个二维数组，就要换一种重复的方式了。

>>> b=tile(a,(2,1))
>>> b
array([[0, 1, 2],
[0, 1, 2]])


--------------------------------------------------------------
python的 numpy当中

现在对于数据的处理更多的还是numpy。没有axis参数表示全部相加，axis＝0表示按列相加，axis＝1表示按照行的方向相加

[python] view plain copy
>>> import numpy as np  
>>> a=np.sum([[0,1,2],[2,1,3]])  
>>> a  
9  
>>> a.shape  
()  
>>> a=np.sum([[0,1,2],[2,1,3]],axis=0)  
>>> a  
array([2, 2, 5])  
>>> a.shape  
(3,)  
>>> a=np.sum([[0,1,2],[2,1,3]],axis=1)  
>>> a  
array([3, 6])  
>>> a.shape  
(2,)  

--------------------------------------------------------------
当我们使用ufunc函数对两个数组进行计算时，ufunc函数会对这两个数组的对应元素进行计算，因此它要求这两个数组有相同的大小(shape相同)。如果两个数组的shape不同的话，会进行如下的广播(broadcasting)处理：
1、让所有输入数组都向其中shape最长的数组看齐，shape中不足的部分都通过在前面加1补齐
2、输出数组的shape是输入数组shape的各个轴上的最大值
3、如果输入数组的某个轴和输出数组的对应轴的长度相同或者其长度为1时，这个数组能够用来计算，否则出错
4、当输入数组的某个轴的长度为1时，沿着此轴运算时都用此轴上的第一组值

我们图片的shape是（200,200,4），而列表的shape是（3，），根据上面的规则1，我们知道列表的shape拓展为（1,1,3）
根据规则2，输出数组的shape为（200,200,4），然后列表的shape不满足规则3，所以出错
